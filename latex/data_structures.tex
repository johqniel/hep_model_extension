\section{Data Storage Logic}
Efficiently storing and retrieving agents is critical for performance. The framework uses a **Structure-of-Arrays (SoA)** approach mixed with object-oriented containers to balance cache efficiency and code maintainability.

\subsection{Design Choice: Hybrid Storage}
The simulation needs to handle millions of agents. Storing each agent as a separate object scattered in memory (as in a pure linked list) would cause excessive cache misses. Conversely, a pure structure-of-arrays can make code harder to read.
We compromise by using a \texttt{world\_container} that holds global arrays, but we expose individual agents via pointers to derived \texttt{Agent} types that "view" the array data.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/data_structure_diagram.png}
    \caption{Visual representation of the hybrid data structure. The \texttt{world\_container} acts as the root, managing contiguous memory arrays for agents while maintaining spatial (Grid) and logical (Hashmap) indices for efficient access.}
    \label{fig:data_structure_diagram}
\end{figure}

\subsection{The Agent Array}
Agents are stored in a large, pre-allocated 2D array within the \texttt{world\_container}:
\begin{lstlisting}[language=Fortran]
type(Agent), allocatable :: agents(:,:) ! (max_size, npops)
\end{lstlisting}
\begin{itemize}
    \item \textbf{Rows}: Iterate through individual agents (up to \texttt{max\_size}).
    \item \textbf{Columns}: Separate different populations (e.g., \texttt{npops}).
\end{itemize}
This allows for contiguous memory access when iterating over a single population, which is the most common operation.

\subsection{Spatial Indexing: The Grid}
For spatial interactions (e.g., mating, conflict), agents are indexed by their geospatial location using the \texttt{Grid} structure.
\begin{itemize}
    \item Each grid cell (\texttt{grid\_cell}) contains a dynamic list of Agent IDs currently located in that cell.
    \item When an agent moves, it is removed from the old cell's list and added to the new cell's list.
\end{itemize}

\subsubsection{Module Types: Agent-Centric vs Cell-Centric}
When developing modules, you must decide the primary access pattern:
\begin{itemize}
    \item \textbf{Agent-Centric Modules}: Functions that apply to a specific agent (e.g., Movement). These iterate over the \texttt{agents} array.
    \begin{lstlisting}[language=Fortran]
    subroutine agent_move(agent_ptr)
        type(Agent), pointer :: agent_ptr
    \end{lstlisting}
    \item \textbf{Cell-Centric Modules}: Functions that apply to a location (e.g., Overpopulation Death). These iterate over the \texttt{grid}.
    \begin{lstlisting}[language=Fortran]
    subroutine death_overpopulation(cell_ptr)
        type(cell), pointer :: cell_ptr
    \end{lstlisting}
\end{itemize}

\section{Module \texttt{mod\_agent\_world}}
This module defines the central \texttt{world\_container} which holds:
\begin{itemize}
    \item \texttt{agents}: The main agent array.
    \item \texttt{grid}: The spatial grid.
    \item \texttt{index\_map}: The ID lookup hashmap.
    \item \texttt{config}: Global configuration parameters.
\end{itemize}
It serves as the "Hub" for all data access.

\subsection{Agent Lookup: Hashmap}
To find an agent by its unique ID (without searching the entire array), the system uses a custom integer hashmap (\texttt{mod\_hashmap}).
\begin{itemize}
    \item \textbf{Key}: Agent ID (Integer).
    \item \textbf{Value}: A composed integer packing both \texttt{population} index and \texttt{array\_index}.
\end{itemize}
This allows $O(1)$ access to any agent pointer given its ID.

\section{Compaction}
When agents die, they are marked with \texttt{is\_dead = .true.}. They are NOT removed immediately to avoid array resizing costs. Instead, a \texttt{compact\_agents} subroutine is called periodically (e.g., end of timestep).
\begin{enumerate}
    \item It iterates from both ends of the array.
    \item Dead agents on the left are overwritten by living agents from the right.
    \item The array size is logically reduced (tracking integer), but physically remains allocated.
\end{enumerate}

\section{Watershed Clustering}
The simulation includes a watershed-based spatial clustering module (\texttt{mod\_watershed} + \texttt{mod\_clustering}) that groups grid cells into clusters based on the HEP surface.

\subsection{Algorithm}
The clustering proceeds in three steps:
\begin{enumerate}
    \item \textbf{Smoothing}: A box filter with half-width \texttt{watershed\_smooth\_radius} is applied to the HEP surface to reduce over-segmentation from noise.
    \item \textbf{Local maxima detection}: Cells strictly higher than all 8 neighbours (and above \texttt{watershed\_threshold}) become cluster seeds.
    \item \textbf{Gradient ascent}: Every remaining unlabelled cell above the threshold follows the steepest-uphill neighbour until a labelled cell is reached. All cells on the path inherit that label.
\end{enumerate}

Cells below the threshold remain unlabelled (noise/water). Cluster IDs are persistent across re-clustering via cell-overlap matching.

\subsection{Configuration}
The watershed clustering parameters are stored in \texttt{world\_config} and read from the namelist file \texttt{basic\_config.nml}:

\begin{center}
\begin{tabular}{|l|l|l|p{6cm}|}
\hline
\textbf{Parameter} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\
\hline
\texttt{watershed\_smooth\_radius} & integer & 2 & Half-width of the box-filter used for smoothing the HEP surface before clustering. Set to 0 to disable smoothing. \\
\hline
\texttt{watershed\_threshold} & real(8) & 0.05 & Cells with HEP values at or below this threshold are classified as noise and excluded from clustering. \\
\hline
\end{tabular}
\end{center}

Example configuration in \texttt{basic\_config.nml}:
\begin{lstlisting}[language=Fortran]
!======================================================
!============ Watershed Clustering ====================
!======================================================
watershed_smooth_radius = 2
watershed_threshold = 0.05
\end{lstlisting}

