\documentclass[14pt,a4paper]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{float}

\geometry{margin=1in}

\title{\textbf{HEP Agent Simulation Framework}\\ \large Interface Documentation}
%\author{Development Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}
The HEP Agent Simulation Framework provides a graphical user interface (GUI) to configure the fortran simulation.
\chapter{Main Graphical Interface}
When launching `application.py`, the user is presented with the main window containing four primary tabs (see Figure \ref{fig:main_window}):
\begin{itemize}
    \item \textbf{Configuration}: For managing simulation settings and HEP inputs.
    \item \textbf{Spawn Editor}: For defining initial agent distribution.
    \item \textbf{View Editor}: For configuring visualization settings.
    \item \textbf{Full Simulation}: For running headless, long-duration simulations.
\end{itemize}
At the bottom of the window, buttons are available to launch the simulation (Figure \ref{fig:live_btn}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{images/Live_View_button.png}
    \caption{Live View Button}
    \label{fig:live_btn}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/Configuration.png}
    \caption{Overview of the Main Application Window (Configuration Tab)}
    \label{fig:main_window}
\end{figure}

\chapter{Configuration Tab}
The Configuration tab serves as the entry point for setting up the simulation parameters.

\section{Configuration List}
On the left side, a list of available `.nml` configuration files is displayed (see Figure \ref{fig:select_config}). Users can select a configuration to view and edit its content in the right-hand text editor.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/Select_input_variable_template.png}
    \caption{Selecting a Configuration File}
    \label{fig:select_config}
\end{figure}

The editor allows direct modification of the simulation parameters within the application (Figure \ref{fig:edit_config}). Note that the \texttt{basic\_config.nml} serves as a template and cannot be modified directly in the editor.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Change_input_variables_in_template.png}
    \caption{Editing Configuration Parameters}
    \label{fig:edit_config}
\end{figure}

\section{HEP Input Selection}
Users can select the HEP input files (Figure \ref{fig:select_hep}):
\begin{itemize}
    \item \textbf{Single HEP File}: Uses the same hep file for all populations.
    \item \textbf{Multiple HEP Files}: Allows specifying distinct hep files for each population.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Select_Hep.png}
    \caption{Selecting HEP Input Files}
    \label{fig:select_hep}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/Configuration.png}
    \caption{Configuration Tab showing file selection and editor}
    \label{fig:config_tab}
\end{figure}

\chapter{Spawn Editor Tab}
The Spawn Editor allows users to define where agents are initially placed on the map (Figure \ref{fig:spawn_editor}). 
This can only be done after a HEP File and a config File have been selected.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/Spawn_Editor.png}
    \caption{Spawn Editor Interface}
    \label{fig:spawn_editor}
\end{figure}

\section{Module Configuration}
The user can activate or deactivate specific simulation modules for the agent population (see Figure \ref{fig:modules}). Note that new modules only appear in this list after the Fortran code has been recompiled and a Fortran-Python interface has been added. This tool serves not as a utility to create new modules, but only to toggle on and off modules that have already been implemented.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Set_Active_Modules.png}
    \caption{Module Activation Panel}
    \label{fig:modules}
\end{figure}

\subsection{Test Modules}
Two special template modules are included for rapid prototyping:
\begin{description}
    \item[Test Module (Agents)] Runs user-defined code once per tick on every living agent. Use this when your logic operates on individual agents (e.g., movement rules, death conditions).
    \item[Test Module (Grid)] Runs user-defined code once per tick on the entire spatial grid. Use this when your logic depends on spatial relationships between agents or grid-cell properties.
\end{description}
To use them, edit \texttt{src/simulation\_modules/mod\_test\_modules.f95}, write your logic in the clearly marked sections, rebuild with \texttt{./build.sh}, and toggle the module on in this panel. For a detailed walkthrough, see Chapter~3 of the \textit{Code Documentation}.

\section{Spawn Point Management}
Users can add, remove, and manage spawn points directly from the list (Figure \ref{fig:manage_spawn}).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Manage_Spawnpoints.png}
    \caption{Spawn Point Management List}
    \label{fig:manage_spawn}
\end{figure}

\section{Preview Context}
The editor allows previewing spawn locations overlaid on the selected HEP environment (Figure \ref{fig:preview_spawn}).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Preview_Spawn_points_and_hep.png}
    \caption{Preview of Spawn Points on HEP Map}
    \label{fig:preview_spawn}
\end{figure}

\chapter{View Editor Tab}
The View Editor controls the visualization parameters for the Live View execution (see Figure \ref{fig:view_editor}).

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/View_Editor.png}
    \caption{View Editor Overview}
    \label{fig:view_editor}
\end{figure}

\section{Map View Settings}
Users can toggle between visualization modes (Figure \ref{fig:map_view_settings}):
\begin{itemize}
    \item \textbf{2D Flat View}: Standard map projection.
    \item \textbf{3D Globe View}: Spherical projection of the simulation data.
\end{itemize}
Additional toggles allow showing/hiding agents and debug counters.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/Map_View_Settings.png}
    \caption{Map View and Visualization Settings}
    \label{fig:map_view_settings}
\end{figure}

\section{Plot Configuration}
A dynamic plotting interface allows users to add real-time analysis charts (Figure \ref{fig:plot_tool}). Supported plot types include:
\begin{itemize}
    \item \textbf{Time Series}: Tracks variable evolution over time (e.g., Total Population).
    \item \textbf{Bucket Plot}: Demographics distribution (e.g., Age cohorts).
    \item \textbf{Count Plot}: Conditional counts (e.g., Number of pregnant agents).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Plot_Creation_Tool.png}
    \caption{Plot Creation Tool}
    \label{fig:plot_tool}
\end{figure}

\chapter{Full Simulation Tab}
The Full Simulation tab is designed for running high-performance, non-interactive simulations (see Figure \ref{fig:full_sim}).

\textbf{Disclaimer: This feature has not been finished yet and is very much a work in progress.}

\section{Parameters}
\begin{itemize}
    \item \textbf{Start/End Year}: Defines the simulation timeline.
    \item \textbf{Output File}: Specifies the path for the simulation recording (.gif).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/Full_Simulation.png}
    \caption{Full Simulation Execution Interface}
    \label{fig:full_sim}
\end{figure}

\chapter{Debugging Fortran Modules}

For instructions on how to \textbf{create} a new simulation module and register it in the framework, please refer to the \textit{Code Documentation} (Chapter~3: ``Developing New Modules'').
This chapter assumes that you are using the \textbf{test modules} (\texttt{mod\_test\_modules.f95}) for the development of your new modules.

\section{Development Workflow Overview}
Developing and debugging a Fortran module requires switching between the Fortran source code, the build system, and the Python UI.
Figure~\ref{fig:debug_workflow} illustrates the typical cycle when working with the test modules.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{images/debug_workflow.png}
    \caption{The edit--build--test cycle for Fortran module development. After editing Fortran source files, the extension must be rebuilt and the Python UI restarted before changes take effect.}
    \label{fig:debug_workflow}
\end{figure}

\section{Print-Based Debugging}
Fortran \texttt{print} statements are the simplest way to inspect values at runtime.
Their output appears in the terminal that launched \texttt{application.py}.

\begin{lstlisting}[language=Fortran]
subroutine my_module(agent_ptr)
    type(Agent), pointer, intent(inout) :: agent_ptr

    print *, "Agent ID:", agent_ptr%id, &
             "pos:", agent_ptr%pos_x, agent_ptr%pos_y
    call flush(6)   ! force output immediately
end subroutine my_module
\end{lstlisting}

\textbf{Tip:} Always call \texttt{flush(6)} after print statements, otherwise output may be lost if the program crashes before the buffer is flushed.

\section{Common Crash Causes}
The most frequent runtime errors when developing Fortran modules are:

\begin{description}
    \item[Segmentation Fault]
    Usually caused by accessing an unallocated or out-of-bounds array, or dereferencing a null pointer.
    Common sources:
    \begin{itemize}
        \item Accessing \texttt{agents(k, pop)} with \texttt{k} beyond \texttt{num\_humans(pop)}.
        \item Using grid indices \texttt{(gx, gy)} that are outside the grid dimensions.
        \item Referencing a dead agent (\texttt{is\_dead = .true.}) that has been compacted away.
    \end{itemize}

    \item[Array Bounds Errors]
    Enable runtime bounds-checking by adding \texttt{-fcheck=all} to the Fortran compiler flags in the build script.
    This turns out-of-bounds accesses into clear error messages instead of silent corruption:
    \begin{lstlisting}[language=bash]
# In build_fortran.sh, add to FFLAGS:
FFLAGS="$FFLAGS -fcheck=all -g -fbacktrace"
    \end{lstlisting}
    \texttt{-g} includes debug symbols, and \texttt{-fbacktrace} prints a stack trace on crashes.

    \item[NaN / Infinity]
    Floating-point issues can propagate silently.
    Use \texttt{-ffpe-trap=invalid,zero,overflow} to trap these at the point of origin:
    \begin{lstlisting}[language=bash]
FFLAGS="$FFLAGS -ffpe-trap=invalid,zero,overflow"
    \end{lstlisting}
\end{description}

\section{Configuration Validation}
When adding new configurable parameters to \texttt{world\_config} (see the Code Documentation), verify that:
\begin{enumerate}
    \item The variable is declared in \texttt{mod\_config.f95} with a sensible default.
    \item The variable is added to the \texttt{namelist /config/} block in \texttt{mod\_read\_inputs.f95}.
    \item A default value is set \textbf{before} the \texttt{read(unit, nml=config)} call.
    \item The variable is assigned to the \texttt{cfg\%} struct \textbf{after} the read.
    \item The variable appears in \texttt{basic\_config.nml}.
\end{enumerate}
If any step is missing, the parameter may silently retain an uninitialised value.

\section{Debug Counters Overlay}
The Live View provides a ``Show Debug Counters'' checkbox (in the View Editor tab) that displays an overlay with runtime statistics including death causes, grid-index errors, and movement calls.
These counters are updated each simulation tick and are useful for verifying that a module's effects are applied as expected.

To add a custom counter:
\begin{enumerate}
    \item Add an integer field to the \texttt{counter} type in \texttt{mod\_agent\_world.f95}.
    \item Increment it inside your module logic.
    \item Expose it via \texttt{get\_debug\_stats} in \texttt{python\_interface.f95}.
\end{enumerate}

\section{Rebuild \& Test Cycle}
After making changes to Fortran source files, always:
\begin{enumerate}
    \item Rebuild the extension:
    \begin{lstlisting}[language=bash]
./build.sh
    \end{lstlisting}
    \item Check the terminal output for compilation warnings --- they often indicate real bugs.
    \item Restart \texttt{application.py} (the old \texttt{.so} is cached by the Python process).
\end{enumerate}

\end{document}
